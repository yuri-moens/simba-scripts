program OGLDraynorChopper;
{$i ogLib\lib\core\core.simba}

{ This script requires ogLib. Learn how to set it up correctly here:
  https://villavu.com/forum/showthread.php?t=112486

  Make sure to set your game window to 'Resizable' and your interface to the
  RuneScape 3 default.

  Change player model IDs at lines 18 and 19. You can get the model IDs by using
  the ogLib debug mode. (check aforementioned thread for more info)

  If you prefer a different screen size, change it at lines 24 and 25. }

{ const Player Constants;
  Description: Constants for the player model. Change these to match your model. }
const
  MODEL_IDLE_ID = 0;
  MODEL_CHOPPING_ID = 0;

{ const Screen Constants;
  Description: Constants for the screen. Change these to your own preference. }
const
  WIDTH = 1440;
  HEIGHT = 900;

{ const Misc Constants;
  Description: Miscellaneous constants for the script. }
const
  GLX_DEBUG = 'none'; // options: none, models, textures, fonts
  VERSION = '1.2.2';

{ const Object Model Constants:
  Description: Constants for various object models. Shouldn't be changed. }
const
  BANKER_MODEL_IDS : tCardinalArray = [1828922260];
  BANK_BOOTH_MODEL_IDS : tCardinalArray = [2697527608];
  WILLOW_MODEL_IDS : tCardinalArray = [2741093185, 3438012135, 135155099];
  TREE_STUMP_MODEL_ID : integer = 3525527804;
  BIRDS_NEST_IDS : tCardinalArray = [3295357347, 2974258964, 1860798043];
  MYSTERIOUS_METEORITE_IDS : tCardinalArray = [1905798070, 3856085471];

{ const Object Texture Constants:
  Description: Constants for various object textures. Shouldn't be changed. }
const
  MINIMAP_FLAG_ID = 1275;
  BANK_ICON_ID = 45052;
  WILLOW_LOGS_ID = 116280;
  SKILL_SELECTION_BOX_ID = 9900;
  METEORITE_CONTINUE_BOX_ID = 91275;

var
  clientCenter, lastTreePoint: tPoint;
  willowModels, nestModels, meteoriteModels: glModelArray;
  canChopTree, canPickupMeteorite, canPickupNest, canWalk, canOpenBank,
    canDeposit, canPrintProgress, canGetExperience: tCountDown = 0;
  willowsCut, totalExperience: integer = 0;
  startTime: integer;

function isUpToDate(): boolean;
var
  i: integer;
  funcVersion: string;
  funcRemoteVersionNumbers, funcLocalVersionNumbers: TStringArray;
begin
  funcVersion := getPage('https://raw.githubusercontent.com/yuri-moens/simba-scripts/master/OGLDraynorChopper.version');
  funcRemoteVersionNumbers := explode('.', funcVersion);
  funcLocalVersionNumbers := explode('.', VERSION);

  for i := low(funcRemoteVersionNumbers) to high(funcRemoteVersionNumbers) do
  begin
    if (strToInt(funcRemoteVersionNumbers[i]) <> strToInt(funcLocalVersionNumbers[i])) then
      exit(false);
  end;

  exit(true);
end;

procedure update()
var
  funcFile: integer;
  funcScript, funcFileName: string;
begin
  funcScript := getPage('https://raw.githubusercontent.com/yuri-moens/simba-scripts/master/OGLDraynorChopper.simba');

  funcFileName := scriptPath + 'OGLDraynorChopper.simba';
  funcFile := rewriteFile(funcFileName, true);

  try
    writeFileString(funcFile, funcScript)
  except
    writeln('Failed to write!');
  end;

  closeFile(funcFile);

  funcFile := rewriteFile(scriptPath + 'DraynorChopperModels.txt', true);

  try
    writeFileString(funcfile, 'MODEL_IDLE_ID: ' + intToStr(MODEL_IDLE_ID) + ', MODEL_CHOPPING_ID: ' + intToStr(MODEL_CHOPPING_ID))
  except
    writeln('Failed to write!');
  end;

  closeFile(funcFile);

  writeln('Script has been updated, please re-open this file and restart the script.');
  writeln('Your model IDs have been saved in DraynorChopperModels.txt');
  terminateScript();
end;

function getExperience(): integer;
var
  funcBounds: tBox;
  funcExpString: string;
  funcPlusPos: integer;
  funcXpPos: integer;
begin
  funcBounds := [clientCenter.x - 100, 0, clientCenter.x + 100, 50];
  funcExpString := ogl.getChars(funcBounds).toString();

  funcPlusPos := pos('+', funcExpString);
  funcXpPos := pos('xp', funcExpString);

  if (funcPlusPos <> 0) and (funcXpPos <> 0) then
  begin
    result := copy(funcExpString, funcPlusPos + 1, funcXpPos - funcPlusPos - 2).parseInt();
    canGetExperience.setTime(2000);
  end
end;

procedure printProgress();
var
  elapsedTime: integer;
  hours: double;
  minutes: double;
begin
  elapsedTime := getSystemTime() - startTime;
  hours := elapsedTime / 3600000;
  minutes := floor(elapsedTime / 60000) mod 60;

  writeln('Running for: ', floor(hours), 'h ', minutes, 'm');
  writeln('Willows cut: ', willowsCut);
  writeln('Willows per hour: ', floor(willowsCut / hours));
  writeln('Experience earned: ', totalExperience);
  writeln('Experience per hour: ', floor(totalExperience / hours));
  writeln('=========================================');

  canPrintProgress.setTime(15000);
end;

function tMouse.clickAction(funcClickPoint: TPoint; funcAction: string): boolean
var
  funcTimeout: tCountDown;
  funcTooltip: string;
begin
  moveMouse(funcClickPoint.x, funcClickPoint.y);

  funcTimeout.setTime(1000);
  repeat
    funcTooltip := mouse.getTooltip()
  until (funcTooltip <> '') or (funcTimeout.isFinished());

  if (funcTooltip <> '') then
  begin
    if (pos(funcAction, funcTooltip) <> 0) then
    begin
      mouse.click(funcClickPoint);
      result := true;
    end
    else
      result := mouse.rightClickOption(funcClickPoint, funcAction);

    exit(result);
  end;

  exit(false);
end;

procedure rotateCamera;
var
  funcIndex: integer;
begin
  for funcIndex := 0 to random(4) do
  begin
    minimap.setDegrees(random(0, 360));
    wait(random(120));
  end;

  if (random(2) = 0) then
     mainScreen.setVerticalDegrees(69);

  minimap.setDegrees(random(332, 353));
end;

procedure twiddleThumbs;
begin
  case Random(533) of
    1: rotateCamera();
  end;
end;

function isTreeCutDown: boolean;
var
  funcStumps : glModelArray;
begin
  funcStumps := ogl.getModels(TREE_STUMP_MODEL_ID);
  if (funcStumps.isEmpty()) then
    result := false
  else
    result := (lastTreePoint.closest(funcStumps)[0].distanceFrom(lastTreePoint) < 10);
end;

function isChopping: boolean;
begin
  if (ogl.getModels(MODEL_CHOPPING_ID).isEmpty()) then
    result := false
  else
  begin
    canChopTree.setTime(0);

    if (isTreeCutDown()) then
      result := false
    else
      result := true;
  end;
end;

function checkTrees: boolean;
begin
  willowModels := ogl.getModels(WILLOW_MODEL_IDS);
  result := not willowModels.isEmpty();
end;

procedure chopTree;
var
  funcClickPoint: TPoint;
begin
  funcClickPoint := clientCenter.closest(willowModels)[0].randomizePointEllipse(55);
  lastTreePoint := funcClickPoint;
  mouse.click(funcClickPoint);
  canChopTree.setTime(random(6000, 8000));
end;

function checkMinimapFlag: boolean;
var
  funcFlagTexture: glTextureArray;
begin
  funcFlagTexture := ogl.getTextures(MINIMAP_FLAG_ID);
  if (not funcFlagTexture.isEmpty()) then
    result := funcFlagTexture[0].distanceFrom(minimap.getPlayer()) > normalRandom(18, 24)
  else
    result := False;
end;

procedure walkToWillows;
begin
  mouse.click(minimap.getScreenPosition(minimap.getLocalPosition()
    .adjustPosition(normalRandom(-10, -6), normalRandom(6, 10))), 1);
  canWalk.setTime(normalRandom(5000, 10000));
end;

procedure walkToBank;
var
  funcClickPoint: tPoint;
begin
  funcClickPoint := clientCenter.closest(ogl.getTextures(BANK_ICON_ID))[0]
    .adjustPosition(normalRandom(-10, -2), normalRandom(0, 10));
  mouse.click(funcClickPoint);
  canWalk.setTime(normalRandom(5000, 10000));
end;

function isAtBank: boolean;
begin
  result := ogl.getTextures(BANK_ICON_ID)[0].distanceFrom(minimap.getPlayer()) < normalRandom(38, 41);
end;

function isBankerVisible: boolean;
begin
  result := not ogl.getModels(BANKER_MODEL_IDS).getVisible().isEmpty();
end;

procedure openBank;
var
  funcClickPoint: tPoint;
begin
  funcClickPoint := clientCenter.closest(ogl.getModels(BANKER_MODEL_IDS))[0]
    .closest(ogl.getModels(BANK_BOOTH_MODEL_IDS))[0].randomizePointEllipse(25);
  mouse.click(funcClickPoint);
  canOpenBank.setTime(normalRandom(6000, 7500));
end;

procedure bankInventory;
begin
  wait(normalRandom(550, 790));

  if (canPrintProgress.isFinished()) then
  begin
    willowsCut := willowsCut + inventory.getItems(WILLOW_LOGS_ID).indexes() - 1;
    printProgress();
  end;

  bank.clickDepositCarriedItems();

  canWalk.setTime(normalRandom(170, 330));
  canDeposit.setTime(2000);
end;

function checkMeteorites: boolean;
begin
  meteoriteModels := ogl.getModels(MYSTERIOUS_METEORITE_IDS);
  result := not meteoriteModels.isEmpty();
end;

procedure pickupMeteorite();
var
  funcTextures: glTextureArray;
  funcClickPoint: tPoint;
  funcTimeout: tCountDown;
begin
  wait(normalRandom(2500,  3000));
  meteoriteModels := ogl.getModels(MYSTERIOUS_METEORITE_IDS); // the model moves so we need to get the updated location
  funcClickPoint := clientCenter.closest(meteoriteModels)[0]
    .randomizePointEllipse(13);

  if (not ogl.getModels(MYSTERIOUS_METEORITE_IDS[0]).isEmpty()) then // take meteorite
    mouse.clickAction(funcClickPoint, 'Take')
  else // interact meteorite
  begin
    mouse.clickAction(funcClickPoint, 'Interact');

    funcTimeout.setTime(normalRandom(7000, 9000));
    repeat
      wait(250);
      funcTextures := ogl.getTextures(SKILL_SELECTION_BOX_ID);
    until (not funcTextures.isEmpty()) or (funcTimeout.isFinished());

    if (not funcTextures.isEmpty()) then
    begin
      funcClickPoint := clientCenter.closest(funcTextures)[0].randomizePointEllipse(7);
      mouse.click(funcClickPoint);
      wait(normalRandom(230, 330));
      funcClickPoint := clientCenter.closest(ogl.getTextures(METEORITE_CONTINUE_BOX_ID))[0]
        .randomizePointEllipse(7);
      mouse.click(funcClickPoint);
    end;
  end;

  canPickupMeteorite.setTime(normalRandom(180000, 190000));
  canChopTree.setTime(normalRandom(4000, 6500));
end;

function checkNests: boolean;
begin
  nestModels := ogl.getModels(BIRDS_NEST_IDS);
  result := not nestModels.isEmpty();
end;

procedure pickupNest();
var
  funcClickPoint: tPoint;
begin
  funcClickPoint := clientCenter.closest(nestModels)[0].randomizePointEllipse(8);
  mouse.rightClickOption(funcClickPoint, 'Take');
  canPickupNest.setTime(normalRandom(2000, 2500));
  canChopTree.setTime(normalRandom(2000, 2500));
end;

procedure logout()
var
  funcBounds: tBox = [WIDTH - 10, 0, WIDTH, 10];
  funcTimeout: tCountDown;
  funcTextures: glTextureArray;
begin
  funcTimeout.setTime(5000);
  writeln('Logging out...');

  mouse.click(funcBounds);

  repeat
    funcTextures := ogl.getTextures(91275, 12483092);
  until (not funcTextures.isEmpty()) or (funcTimeout.isFinished());

  if (not funcTextures.isEmpty()) then
    mouse.click(clientCenter.closest(funcTextures)[0].randomizePointEllipse(15));
end;

procedure mainLoop;
var
  funcReaction: procedure() = @twiddleThumbs;
begin
  if (canGetExperience.isFinished()) then
    totalExperience := totalExperience + getExperience();

  if (isAtBank()) then
  begin
    if (inventory.isFull()) then
    begin
      if (bank.hasBank() and canDeposit.isFinished()) then
        funcReaction := @bankInventory
      else if (canOpenBank.isFinished()) then
        funcReaction := @openBank
    end
    else if (canWalk.isFinished()) then
      funcReaction := @walkToWillows
  end
  else
  begin
    if (not inventory.isFull()) then
    begin
      if (checkMeteorites()) then
      begin
        if (canPickupMeteorite.isFinished()) then
          funcReaction := @pickupMeteorite
      end
      else if (checkNests()) then
      begin
        if (canPickupNest.isFinished()) then
          funcReaction := @pickupNest
      end
      else if (not isChopping())
        and (checkTrees())
        and (not checkMinimapFlag())
        and (canChopTree.isFinished()) then
        funcReaction := @chopTree
    end
    else if (canWalk.isFinished()) then
      funcReaction := @walkToBank
  end;

  funcReaction();
end;

begin
  ogl.setup(WIDTH, HEIGHT);
  clientCenter := ogl.getClientMidPoint();
  startTime := getSystemTime();
  ogl.setDebugMode(GLX_DEBUG);

  if (not isUpToDate()) then
    update();

  writeln('[OGL] Draynor Chopper v', VERSION, ' by ChaosEnergy');
  writeln('=========================================');

  try
    repeat
      mainLoop;
      wait(normalRandom(220, 670));
    until false;
  except
    writeln('Oops! It appears I have crashed.');
    logout();
    terminateScript();
  end;
end.